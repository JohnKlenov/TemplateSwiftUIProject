//
//  RunLoopSetting.swift
//  TemplateSwiftUIProject
//
//  Created by Evgenyi on 6.07.25.
//

import Foundation

// почему в  func signUp(email: String, password: String) при .finished вызов alert оборачиваем в DispatchQueue.main.async?

/// потому что операции NotificationCenter.default.post + alert + .. будут вызваны последовательно (Система начинает обработку цепочки синхронно в текущем run loop)
/// когда начинутся Навигационные изменения (popToRoot) они не успеют завершится как вызовется алерт - Навигационные изменения (popToRoot) ставятся в очередь, но не могут выполниться, пока не завершится показ алерта.
/// DispatchQueue.main.async добавляет задачу в конец текущего цикла RunLoop
/// Навигационные изменения успевают обработаться до показа алерта
/// Даже с задержкой 0 это работает, потому что это уже следующий "тик" системы

// Без async:
/// Один "тик" RunLoop
//┌──────────────┐
//│ 1. Навигация │
//│ 2. Алерт     │ ← блокирует завершение 1
//└──────────────┘

//С async:
/// Первый "тик"
//┌──────────────┐
//│ 1. Навигация │ ← выполняется полностью
//└──────────────┘
/// Второй "тик"
//┌──────────────┐
//│ 2. Алерт     │
//└──────────────┘


//Всегда используйте DispatchQueue.main.async для:Показа алертов после навигации + Любых UI-изменений, которые должны произойти после системных анимаций



//RunLoop

//RunLoop — это механизм, который управляет обработкой событий в потоке (обычно в главном потоке UI). Это бесконечный цикл.
//RunLoop.main — "сердце" главного потока, обрабатывает UI и задачи из DispatchQueue.main
//GCD — система очередей, которая поставляет задачи в RunLoop (для main queue) или работает параллельно (для global queues)
//Не блокируйте RunLoop задачами >16ms. Всё тяжёлое — на фоновые очереди.

//Приоритеты задач в RunLoop:
///Когда RunLoop выбирает, что выполнить в следующем тике:
///UI-обновления: ★★★★★    + Анимации: ★★★★☆    + Задачи из DispatchQueue.main: ★★★☆☆ + Таймеры: ★★☆☆☆    + Источники данных: ★☆☆☆☆

//RunLoop и GCD: как взаимодействуют
///a) DispatchQueue.main: Задачи из DispatchQueue.main попадают в очередь RunLoop. + Выполняются между обработкой UI-событий.
///b) Другие очереди GCD (global, concurrent): Не влияют на RunLoop напрямую. + Если хотят обновить UI — должны перейти на DispatchQueue.main:


//Tick

//Tick — это один полный проход RunLoop (один цикл обработки событий).
///60 FPS → 60 тиков/сек (если RunLoop успевает)
///Каждый тик = обработка всех изменений за этот "кадр"
///Теоретический максимум: При 60 FPS: до ~60 тиков/сек (каждый тик ≈ 16.6 мс) / При 120 FPS: до ~120 тиков/сек (каждый тик ≈ 8.3 мс) - Но это идеальные значения. В реальности:
///
///60 FPS устройство, задачи по 1мс
/// Теоретически: 1000ms / (16.6ms + 1ms) ≈ 57 тиков/сек
///
///120 FPS устройство, задачи по 10мс
/// Реально: 1000ms / (8.3ms + 10ms) ≈ 55 тиков/сек (вместо 120!)

//RunLoop не гарантирует фиксированное число тиков — это динамическая величина.
//Чем больше нагрузка на главный поток, тем меньше тиков:
///Анимация скролла будет выглядеть менее плавной, как если бы устройство работало на 55 Гц вместо 120 Гц.
//Решение:
///Тяжёлые задачи → фоновые очереди. + Обязательно замеряйте FPS в Instruments. + Держите главный поток свободным для отрисовки кадров.
