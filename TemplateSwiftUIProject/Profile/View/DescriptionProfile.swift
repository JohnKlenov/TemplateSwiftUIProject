
//Control + Command + Space

// MARK: - когда внутри Cloud Function что‑то пошло не так и ты залогировал logger.error


//Что делают профессионально в продакшене

//1. Логирование + алертинг

///logger.error сам по себе пишет в Google Cloud Logging (Stackdriver).
///На продакшене обычно настраивают алерты: если за последние N минут появилось M ошибок → отправить уведомление в Slack, Teams, Email, PagerDuty. это делается через Google Cloud Monitoring (Alerting Policies).
///Таким образом команда узнаёт о проблеме сразу, а не через неделю.


//2. Повторное выполнение (retry)

///Для background‑функций (например, Pub/Sub, Firestore triggers) можно включить автоматический retry. Если функция завершилась с ошибкой (бросила исключение), Cloud Functions сам попробует её выполнить снова. Это полезно для временных сбоев (например, сеть, таймаут).
///Для HTTP‑функций retry не включается автоматически — клиент сам должен повторить запрос.


//3. Dead Letter Queue (DLQ)

///Если функция всё равно падает после нескольких ретраев, сообщения можно складывать в Pub/Sub DLQ (отдельную очередь).
///Потом разработчики вручную или через отдельный воркер разбирают эти «проблемные события».
///Это защищает от потери данных.


//4. Идемпотентность

///Важно писать функции так, чтобы повторный запуск не ломал данные. Например, если удаление пользователя вызвалось дважды — это не должно привести к ошибке. Если запись в Firestore уже существует — setData(..., merge: true) или updateData должны корректно отработать.


//5. Оповещение команды


///В продакшене редко читают «сырые» логи.
///Обычно ошибки агрегируются в Sentry, Datadog, New Relic или хотя бы в Slack‑канал с алертами.
///Там сразу видно: какой сервис, какой стек‑трейс, сколько раз повторилось.



//Как это выглядит на практике

///Функция упала → logger.error → запись в Cloud Logging.
///Cloud Monitoring видит, что за 5 минут >10 ошибок → шлёт алерт в Slack.
///Если включён retry → функция сама попробует ещё раз.
///Если и после retry ошибка → событие уходит в DLQ.
///Команда утром видит алерт + DLQ и разбирает кейс.






// MARK: - problem

// DeleteAccount
//
// удаление перманентного пользователя прошло успешно!
//Но ошибки прилетают в консоль!
//То есть мы можем отключить наблюдателя и нам не придет эта ошибка в коде но на стороне сервера  :
//11.4.0 - [FirebaseFirestore][I-FST000001] Listen for query at users/Tk9KhQf87IYgelIIYSLvKZt8Z0C2/data failed: Missing or insufficient permissions.
//11.4.0 - [FirebaseFirestore][I-FST000001] Listen for query at users/Tk9KhQf87IYgelIIYSLvKZt8Z0C2/userProfileData/Tk9KhQf87IYgelIIYSLvKZt8Z0C2 failed: Missing or insufficient permissions.



// MARK: - Shared task

// state = .loading
// оставить активный спинер на кнопке где была инициализирована операция аутентификации
// на остальных связанных со state кнопках аутентификации блокировать нажатия до тех пор пока state = .loading
// как такое реализовать ? state для каждой кнопки и один общий для всех?
//
//
// final class AuthorizationManager: @Published private(set) var state: State = .idle
// когда у нас state = .loading то на всех View в которых есть связь с этим @Published сейчас крутится спинер.
// это сбивает с току пользоваетля - нужно убрать уту реализацию с Profile/SignIn/SignUp/ReauthView
// но использовать этот state как блокировку активных кнопок аутентификации пока идет загрузка:
// Auth операции (SignIn / SignUp / DeleteAccount)
//
// - В боевых приложениях не допускают параллельных auth‑операций.
// - Пока выполняется SignIn или SignUp, UI блокирует другие действия (например, DeleteAccount).
// - Причина: Firebase Auth поддерживает только одного currentUser, параллельные вызовы создают гонки.
// - Правильный паттерн: "одна auth‑операция за раз" + возможность отмены на уровне UI.
// - Таким образом сохраняется консистентность и предсказуемое поведение.
//





// MARK: - Task for Profile and child views


// first queue

// ✅ ReauthenticateView one provaider
//
//
// Профессиональный паттерн:
//
// - Мы не даём возможность привязывать несколько провайдеров к одному аккаунту.
// - Аккаунт создаётся только с одним провайдером (Email, Google или Apple).
// - На экране SignIn/SignUp всегда показываем все три варианта,
//   чтобы пользователь выбрал способ регистрации.
//
// - На экране ReauthenticateView:
//   • перед отрисовкой определяем, к какому провайдеру привязан аккаунт,
//   • отображаем только этот способ реаутентификации,
//   • это исключает путаницу и ошибки (.userMismatch).
//
// Итог:
// - Так делают на боевых приложениях: выбор провайдера при регистрации,
//   а при реаутентификации — строго тот же провайдер, что у аккаунта.
//
//
// Регистрация с выбором одного провайдера vs мульти‑провайдерность:
//
// - Мульти‑провайдерность (через user.link(with:)) добавляют только если:
//   • есть бизнес‑ценность (запасной способ входа),
//   • нужно повысить retention,
//   • требуется гибкость входа с разных устройств.
//
// Итог:
// - Можно не использовать мульти‑провайдерность.
// - Выбор одного провайдера при регистрации — это нормальная и распространённая практика.
//
//
// Как иметь несколько провайдеров входа на одном аккаунте:
//
// - Базовый вход (например, Email/Password) создаёт currentUser с UID.
// - В настройках показываем кнопки "Привязать Google/Apple".
// - Получаем credential второго провайдера и вызываем:
//     user.link(with: newCredential) { ... }
// - Успех: в user.providerData появляется второй провайдер,
//   один и тот же UID теперь доступен через несколько способов входа.
// - Нюансы:
//   • link работает только на текущем пользователе,
//   • возможны конфликты, если credential уже привязан к другому аккаунту,
//   • для чувствительных действий может потребоваться реаутентификация.
// - Telegram: вход по номеру телефона; привязки Google/Apple именно как способов
//   логина к Telegram-аккаунту нет — это фича auth-платформ (например, Firebase).
//

// forgot password for ReauthenticateView and SignIn

// add new provaider auth (Apple + Google)

// second queue
// Добавить локализацию текста (использовать Localizable.strings) Profile views + child class.
// Адаптировать UI под разные устройства (Auto Layout, Dynamic Type).
// Локализовать Color (через Asset Catalog с поддержкой локализаций).




// текущие тесты:

// текущий анон слинковать с email 799 что бы проверить forgot password


